<style>blockquote{  font-style: normal;  margin-left: 32px;  border-left: 4px solid #CCC;  padding-left: 30px;}</style>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.min.css" integrity="sha256-77qGXu2p8NpfcBpTjw4jsMeQnz0vyh74f5do0cWjQ/Q=" crossorigin="anonymous" />

  <title>ESXi Python</title>
  
  <meta name="description" content="Cluster">
  <meta name="author" content="Jean-Marc Menaud">
</head>

<body>
  <div class="container">
  

	
  <h1>ESXi Python access</h1>
  	<p>
	</p>
	
	
	 <!-- PARTIE 1 -->
  <div class="border-top">

	<h2>0 Intro</h2> 
	<h3>0.2 First test  <span class="badge badge-secondary">5 minutes</span></h3>
	Exécuter le fichier <a href="http://www.menaud.fr/Cours/Cloud/TP/TP3-Python/intro.py" target="_blank"> intro.py </a><br>
	Que fait ce programme ?
	
  <pre><code>Le programme définit trois variables x, y, z.
  La variable x a une valeur comprise dans l'intervale [0, 1]. 
  La variable y a une valeur comprise dans l'intervale [0, 2]. 
  La variable z a une valeur comprise dans l'intervale [0, 3]. 
  Le programme calcule les valeurs de ces trois variables afin que x soit
  différent de y.
  </code></pre>
	<pre><code class="language-python">from ortools.sat.python import cp_model

model = cp_model.CpModel()
x = model.NewIntVar(0, 1, 'x')
y = model.NewIntVar(0, 2, 'y')
z = model.NewIntVar(0, 3, 'z')
model.Add(x != y)
solver = cp_model.CpSolver()
status = solver.Solve(model)
print(status)
	</code></pre>

	<h3>0.3 solve()  <span class="badge badge-secondary">5 minutes</span></h3>
	La fonction solver.solve() retourne un statut pouvant avoir 5 valeurs.<br>
    Quelles sont les statuts possibles pour un problème possèdant des solutions ?

<pre><code class="language-python">from ortools.sat.python import cp_model

model = cp_model.CpModel()
x = model.NewIntVar(0, 1, 'x')
y = model.NewIntVar(0, 2, 'y')
z = model.NewIntVar(0, 3, 'z')
model.Add(x != y)
model.Add(x < z)
solver = cp_model.CpSolver()
status = solver.Solve(model)
if status == cp_model.OPTIMAL:
    print("optimal")
elif status == cp_model.FEASIBLE:
    print("feasible")
elif status == cp_model.INFEASIBLE:
    print("infeasible")
elif status == cp_model.MODEL_INVALID:
    print("invalid model")
elif status == cp_model.UNKNOWN:
    print("no solution or problem can not be proven INFEASIBLE")
</code></pre>

	<h3>0.4 x,y,z  <span class="badge badge-secondary">5 minutes</span></h3>
	Modifier le programme afin d'afficher les valeurs de x, y et z de la solution
  	trouvée par le solveur. <br>
  	Quelles sont les valeurs de x, y et z ?
 <pre><code class="language-python">from ortools.sat.python import cp_model

model = cp_model.CpModel()
x = model.NewIntVar(0, 1, 'x')
y = model.NewIntVar(0, 2, 'y')
z = model.NewIntVar(0, 3, 'z')
model.Add(x != y)
model.Add(x < z)
solver = cp_model.CpSolver()
status = solver.Solve(model)
if status == cp_model.OPTIMAL:
    print("optimal")
elif status == cp_model.FEASIBLE:
    print("feasible")
elif status == cp_model.INFEASIBLE:
    print("infeasible")
elif status == cp_model.MODEL_INVALID:
    print("invalid model")
elif status == cp_model.UNKNOWN:
    print("no solution or problem can not be proven INFEASIBLE")
if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    print(solver.Value(x))
    print(solver.Value(y))
    print(solver.Value(z))
</code></pre>
 	
	<h3>0.5 x < z  <span class="badge badge-secondary">5 minutes</span></h3>
		Modifier le programme pour ajouter la contrainte : "x doit être strictement
  	plus petit que z". <br>
  	Quelles sont les valeurs de x, y et z ?
<pre><code class="language-python">from ortools.sat.python import cp_model

model = cp_model.CpModel()
x = model.NewIntVar(0, 1, 'x')
y = model.NewIntVar(0, 2, 'y')
z = model.NewIntVar(0, 3, 'z')
model.Add(x != y)
model.Add(x < z)
solver = cp_model.CpSolver()
status = solver.Solve(model)
if status == cp_model.OPTIMAL:
    print("optimal")
elif status == cp_model.FEASIBLE:
    print("feasible")
elif status == cp_model.INFEASIBLE:
    print("infeasible")
elif status == cp_model.MODEL_INVALID:
    print("invalid model")
elif status == cp_model.UNKNOWN:
    print("no solution or problem can not be proven INFEASIBLE")
if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    print(solver.Value(x))
    print(solver.Value(y))
    print(solver.Value(z))


  </code></pre>  
    
  	<h3>0.6 all  <span class="badge badge-secondary">5 minutes</span></h3>
  	À l'aide de la documentation et de la classe VarArraySolutionPrinter du module
  s_printer.py, afficher toutes les solutions du problème décrits. Lister les
  solutions obtenues.<br>
  <i>Pour importer la classe VarArraySolutionPrinter, utiliser la ligne suivante:
    `from s_printer import VarArraySolutionPrinter`</i>
<pre><code class="language-python">from ortools.sat.python import cp_model


class VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""

    def __init__(self, variables):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self.__variables = variables
        self.__solution_count = 0

    def on_solution_callback(self):
        self.__solution_count += 1
        for v in self.__variables:
            print('%s=%i' % (v, self.Value(v)), end=' ')
        print()

    def solution_count(self):
        return self.__solution_count


class VarArraySolutionPrinterWithLimit(cp_model.CpSolverSolutionCallback):
    """Print intermediate solutions."""

    def __init__(self, variables, limit, vmCosts):
        cp_model.CpSolverSolutionCallback.__init__(self)
        self.__variables = variables
        self.__solution_count = 0
        self.__solution_limit = limit
        self.__vm_costs = vmCosts

    def on_solution_callback(self):
        self.__solution_count += 1
        cost = 0
        idx = 0
        for v in self.__variables:
            print('%s=%i' % (v, self.Value(v)), end=' ')
            if self.Value(v) == 1:
                cost += self.__vm_costs[idx]
            idx += 1
        print("cost=%d" % cost)
        if self.__solution_count >= self.__solution_limit:
            print('Stop search after %i solutions' % self.__solution_limit)
            self.StopSearch()

    def solution_count(self):
        return self.__solution_count

    def last_solution(self):
        return [ self.Value(v) for v in self.__variables]
   </code></pre>  
       
      	<h3>1.1 Profit for a Cloud provider  <span class="badge badge-secondary">5 minutes</span></h3>
  We are a cloud provider. We have already sold 5 VMs to ours clients. Each VM has a cost (between 1 to 10 dollars) for our client (ex [10,3,5,1,9]). Print on the screen our profit.
  
<pre><code class="language-python">vmCost = [10, 3, 5, 1, 9]
print("Short answer:")
print("cost: %d" % sum(vmCost))
print("Long answer:")
cost = 0
for c in vmCost:
    cost += c
print("cost: %d" % sum(vmCost))
</code></pre>

<h2>2 Profit with Contention for a Cloud provider</h2>
We have 5 VMs. Each VM has a State (0=Off, 1=On). Our data center is very limited, so we cant host all clients VMs. In our new problem, we want exactly nbRunning VMs On. Every VM can have the value 0 (off VM) or 1 (on VM). The sum of every VM state must be equal to nbRunning. We can use the VarArraySolutionPrinterWithLimit() solution printer to display only N solutions. For example, VarArraySolutionPrinterWithLimit(x, 3) displays the 3 solutions of the problem. We can use the function last_solution() to retrieve the variable values of the last solution in an array.
	
<h3>2.1 Contention on the Infrastructure <span class="badge badge-secondary">5 minutes</span></h3>
Write a code to compute the state of the 5 VM. Print all VM States and compute the cost.

<pre><code class="language-python">from ortools.sat.python import cp_model
from s_printer import VarArraySolutionPrinter


vmCosts = [ 10, 3, 5, 1, 9 ]
nbRunning = 2
# Constraint programming model
model = cp_model.CpModel()
# CP Variables
vm1 = model.NewIntVar(0, 1, 'vm1')
vm2 = model.NewIntVar(0, 1, 'vm2')
vm3 = model.NewIntVar(0, 1, 'vm3')
vm4 = model.NewIntVar(0, 1, 'vm4')
vm5 = model.NewIntVar(0, 1, 'vm5')
# Constraints
model.Add(vm1 + vm2 + vm3 + vm4 + vm5 == nbRunning)
# Solve the problem
solver = cp_model.CpSolver()
status = solver.Solve(model)
if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
    print("vm1: %d" % solver.Value(vm1))
    print("vm2: %d" % solver.Value(vm2))
    print("vm3: %d" % solver.Value(vm3))
    print("vm4: %d" % solver.Value(vm4))
    print("vm5: %d" % solver.Value(vm5))
    cost = 0
    if solver.Value(vm1) == 1:
        cost += vmCosts[0]
    if solver.Value(vm2) == 1:
        cost += vmCosts[1]
    if solver.Value(vm3) == 1:
        cost += vmCosts[2]
    if solver.Value(vm4) == 1:
        cost += vmCosts[3]
    if solver.Value(vm5) == 1:
        cost += vmCosts[4]
    print("cost: %d" % cost)

"""
# Display all solutions
solution_printer = VarArraySolutionPrinter([vm1, vm2, vm3, vm4, vm5])
status = solver.SearchForAllSolutions(model, solution_printer)
"""
</code></pre>
		
<h3>2.2 Generic solution fo contention on the Infrastructure <span class="badge badge-secondary">15 minutes</span></h3>

	Use one variable nbVM to define the number of VM of our datacenter. 
	Define the number of the model variables from the nbVM variable. For example,

	<div style="padding:3px; border:2px dotted #a5a5a5; background-color:#e3e3e3;">
   variables = []<br>
   for i in range(nbVM):<br>
   &nbsp;&nbsp;&nbsp;&nbsp;variables.append(model.NewIntVar(0, X, 'vm%i'))<br>
	</div>
   
   Display 5 solutions of our problem and compute the cost for one of them.
  
  <pre><code class="language-python">from ortools.sat.python import cp_model
from s_printer import VarArraySolutionPrinterWithLimit


vmCosts = [ 10, 3, 5, 1, 9 ]
nbVm = len(vmCosts)
nbRunning = 2
# Constraint programming model
model = cp_model.CpModel()
# CP Variables
x = [ model.NewIntVar(0, 1, 'vm%i' % i) for i in range(nbVm) ]
# Constraints
model.Add(sum(x) == nbRunning)
# Solve the problem
solver = cp_model.CpSolver()
# Display solutions
solution_printer = VarArraySolutionPrinterWithLimit(x, 5)
status = solver.SearchForAllSolutions(model, solution_printer)
# Compute the cost
last_result = solution_printer.last_solution()
cost = 0
for i in range(nbVm):
    if last_result[i] == 1:
        cost += vmCosts[i]
print("cost of the last solution: %d" % cost)
</code></pre>


<h3>2.3 Cost of every solution  <span class="badge badge-secondary">5 minutes</span></h3>
Create the class VarArraySolutionPrinterWithLimitAndCost 
	that displays the cost of every solution. 
	The __init__ method shoud have the following 
	arguments: __init__(self, variables, limit, vmCosts)
   
   <pre><code class="language-python">from ortools.sat.python import cp_model
from s_printer_correction import VarArraySolutionPrinterWithLimit


vmCosts = [ 10, 3, 5, 1, 9 ]
nbVm = len(vmCosts)
nbRunning = 2
# Constraint programming model
model = cp_model.CpModel()
# CP Variables
x = [ model.NewIntVar(0, 1, 'vm%i' % i) for i in range(nbVm) ]
# Constraints
model.Add(sum(x) == nbRunning)
# Solve the problem
solver = cp_model.CpSolver()
# Display solutions
solution_printer = VarArraySolutionPrinterWithLimit(x, 5, vmCosts)
status = solver.SearchForAllSolutions(model, solution_printer)
# Compute the cost
last_result = solution_printer.last_solution()
cost = 0
for i in range(nbVm):
    if last_result[i] == 1:
        cost += vmCosts[i]
print("cost: %d" % cost)
</code></pre>

<h3>2.4 exactly nbRunning VM  <span class="badge badge-secondary">5 minutes</span></h3>
Now, we want exactly nbRunning VM while maximizing our profit. 
	Compute and display the optimal solution using the model.Maximize() function.

<pre><code class="language-python">from ortools.sat.python import cp_model
from s_printer_correction import VarArraySolutionPrinterWithLimit


STATES = [ "off", "on" ]
vmCosts = [ 10, 3, 5, 1, 9 ]
nbVm = len(vmCosts)
nbRunning = 2
# Constraint programming model
model = cp_model.CpModel()

# CP Variables
x = [ model.NewIntVar(0, 1, 'vm%i' % i) for i in range(nbVm) ]

# Constraints
model.Add(sum(x) == nbRunning)
total_cost = []
for i in range(nbVm):
    total_cost.append(x[i] * vmCosts[i])
model.Maximize(sum(total_cost))
# Short way to write the same code
# model.Maximize(sum([x[i] * vmCosts[i] for i in range(nbVm)]))

# Solve the problem
solver = cp_model.CpSolver()

# Display solutions
status = solver.Solve(model)

# Compute the cost
if status == cp_model.OPTIMAL:
    print("Maximum profit: %d" % solver.ObjectiveValue())
    for idx, vm in enumerate(x):
        print("vm%d: %s" % (idx, STATES[solver.Value(vm)]))
</code></pre>


<h2>3</h2>
<h3>3.1 first experiment <span class="badge badge-secondary">5 minutes</span></h3>
We have 5 objects with [2, 2, 5, 8, 5] for their capacities. 
	We have 4 bins of 8. By using the google
	example(https://developers.google.com/optimization/bin/bin_packing), write a
	code that solves this problem.
	<pre><code class="language-python">from ortools.linear_solver import pywraplp

# Variables
nbBins = 4
binCapacity = 8
objectWeights = [2, 2, 5, 5, 8]

solver = pywraplp.Solver.CreateSolver('SCIP')

# Solver Variables
# y[j] = 1 if bin j is used.
bins = {}
for j in range(nbBins):
    bins[j] = solver.IntVar(0, 1, 'bin_%i' % j)
# x[i, j] = 1 if item i is packed in bin j.
objects = {}
for i in range(len(objectWeights)):
    for j in range(nbBins):
        objects[(i, j)] = solver.IntVar(0, 1, 'object_%i_%i' % (i, j))

# Constraints
# Each item must be in exactly one bin.
for i in range(len(objectWeights)):
    solver.Add(sum(objects[i, j] for j in range(nbBins)) == 1)
# The amount packed in each bin cannot exceed its capacity.
for j in range(nbBins):
    solver.Add(sum(
        [ objects[(i, j)] * objectWeights[i] for i in range(len(objectWeights))]
        ) <= bins[j] * binCapacity)
solver.Minimize(solver.Sum([bins[j] for j in range(nbBins)]))
status = solver.Solve()
if status == pywraplp.Solver.OPTIMAL:
    binObjects = []
    for j in range(nbBins):
        binObjects.append([])
    for i in range(len(objectWeights)):
        for j in range(nbBins):
            if objects[i, j].solution_value() == 1:
                binObjects[j].append(i)
    for idx, content in enumerate(binObjects):
        print("Inside bin%d:" % idx)
        for i in content:
            print("  object%d (weight: %d)" % (i, objectWeights[i]))
</code></pre>
<h3>3.2 Explain  <span class="badge badge-secondary">5 minutes</span></h3>
<h2>4</h2>
<h3>4.1 Server capacity  <span class="badge badge-secondary">5 minutes</span></h3>
	We add the server concept in our data center. Each server has a capacity.
   	Each VM a consumption. So, we add 2 servers with 10 and 20 for their
  	capacities. Our 5 VMs have [10,5,3,5,7] for their consumption. All VM are On.
   	Each VM On must be placed on a server. So, if the VM1 is placed on Server1,
   	the VM1 will consume all Server1 capacities. Find a correct placement.
   	<pre><code class="language-python">from ortools.linear_solver import pywraplp

# Variables
serverCapacity = [ 10, 20 ]
nbServers = len(serverCapacity)
vmConso = [ 5, 5, 3, 10, 7]
nbVms = len(vmConso)

solver = pywraplp.Solver.CreateSolver('SCIP')

# Solver Variables
# y[j] = 1 if bin j is used.
servers = {}
for j in range(nbServers):
    servers[j] = solver.IntVar(0, 1, 'server_%i' % j)
# x[i, j] = 1 if item i is packed in bin j.
vms = {}
for i in range(nbVms):
    for j in range(nbServers):
        vms[(i, j)] = solver.IntVar(0, 1, 'vm_%i_%i' % (i, j))

# Constraints
# Each item must be in exactly one bin.
for i in range(nbVms):
    solver.Add(sum(vms[i, j] for j in range(nbServers)) == 1)
# The amount packed in each bin cannot exceed its capacity.
for j in range(nbServers):
    solver.Add(sum(
        [ vms[(i, j)] * vmConso[i] for i in range(nbVms)]
        ) <= servers[j] * serverCapacity[j])
status = solver.Solve()
if status == pywraplp.Solver.OPTIMAL:
    vmPlacement = []
    for j in range(nbServers):
        vmPlacement.append([])
    for i in range(nbVms):
        for j in range(nbServers):
            if vms[i, j].solution_value() == 1:
                vmPlacement[j].append(i)
    for idx, content in enumerate(vmPlacement):
        print("On server%d (capacity: %d):" % (idx, serverCapacity[idx]))
        for i in content:
            print("  vm%d (weight: %d)" % (i, vmConso[i]))
            </code></pre>
<h3>4.2 ...  <span class="badge badge-secondary">5 minutes</span></h3>
	We want exactly nbRunning VM On. For that, we define a ghost server (like a
   	trash). This ghost server has a big capacity, each All Vm Off must be placed
   	on the Ghost server. 
   	<pre><code class="language-python">from ortools.linear_solver import pywraplp

# Variables
serverCapacity = [ 10, 20, 10000 ]
nbServers = len(serverCapacity)
# We define the trash server as the last server of the list
trashServerIdx = nbServers - 1
vmConso = [ 5, 5, 3, 10, 7]
nbVms = len(vmConso)
nbRunning = 2

solver = pywraplp.Solver.CreateSolver('SCIP')

# Solver Variables
# y[j] = 1 if bin j is used.
servers = {}
for j in range(nbServers):
    servers[j] = solver.IntVar(0, 1, 'server_%i' % j)
# x[i, j] = 1 if item i is packed in bin j.
vms = {}
for i in range(nbVms):
    for j in range(nbServers):
        vms[(i, j)] = solver.IntVar(0, 1, 'vm_%i_%i' % (i, j))

# Constraints
# Each VM must be in exactly one server.
for i in range(nbVms):
    solver.Add(sum(vms[i, j] for j in range(nbServers)) == 1)
# The amount packed in each server cannot exceed its capacity.
for j in range(nbServers):
    solver.Add(sum(
        [ vms[i, j] * vmConso[i] for i in range(nbVms)]) <= servers[j] * serverCapacity[j])
# Off VM are hosted on the third server (trash server)
solver.Add(sum([ vms[i, trashServerIdx] for i in range(nbVms)]) == nbVms - nbRunning)

status = solver.Solve()
if status == pywraplp.Solver.INFEASIBLE:
    print("No Solution")
if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:
    vmPlacement = []
    for j in range(nbServers):
        vmPlacement.append([])
    for i in range(nbVms):
        for j in range(nbServers):
            if vms[i, j].solution_value() == 1:
                vmPlacement[j].append(i)
    for idx, content in enumerate(vmPlacement):
        print("On server%d (capacity: %d):" % (idx, serverCapacity[idx]))
        for i in content:
            print("  vm%d (weight: %d)" % (i, vmConso[i]))
            </code></pre>


<h3>4.3 ...  <span class="badge badge-secondary">5 minutes</span></h3>
	Same as previous question, but we want maximize our profit.
<pre><code class="language-python">from ortools.linear_solver import pywraplp

# Variables
serverCapacity = [ 10, 20, 10000 ]
nbServers = len(serverCapacity)
# We define the trash server as the last server of the list
trashServerIdx = nbServers - 1
vmConso = [ 5, 5, 3, 10, 7]
vmCosts = [ 10, 3, 5, 1, 9 ]
nbVms = len(vmConso)
nbRunning = 2

solver = pywraplp.Solver.CreateSolver('SCIP')

# Solver Variables
# y[j] = 1 if bin j is used.
servers = {}
for j in range(nbServers):
    servers[j] = solver.IntVar(0, 1, 'server_%i' % j)
# x[i, j] = 1 if item i is packed in bin j.
vms = {}
for i in range(nbVms):
    for j in range(nbServers):
        vms[(i, j)] = solver.IntVar(0, 1, 'vm_%i_%i' % (i, j))

# Constraints
# Each VM must be in exactly one server.
for i in range(nbVms):
    solver.Add(sum(vms[i, j] for j in range(nbServers)) == 1)
# The amount packed in each server cannot exceed its capacity.
for j in range(nbServers):
    solver.Add(sum(
        [ vms[i, j] * vmConso[i] for i in range(nbVms)]) <= servers[j] * serverCapacity[j])
# Off VM are hosted on the third server (trash server)
solver.Add(sum([ vms[i, trashServerIdx] for i in range(nbVms)]) == nbVms - nbRunning)
# Compute the cost of all VM hosted on a different server than the trash server
total_cost = []
for i in range(nbVms):
    total_cost.append(sum([vms[i, j] for j in range(nbServers - 1)]) * vmCosts[i])
solver.Maximize(sum(total_cost))

status = solver.Solve()
if status == pywraplp.Solver.INFEASIBLE:
    print("No Solution")
if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:
    vmPlacement = []
    for j in range(nbServers):
        vmPlacement.append([])
    for i in range(nbVms):
        for j in range(nbServers):
            if vms[i, j].solution_value() == 1:
                vmPlacement[j].append(i)
    for idx, content in enumerate(vmPlacement):
        print("On server%d (capacity: %d):" % (idx, serverCapacity[idx]))
        for i in content:
            print("  vm%d (cons: %d, cost: %d)" % (i, vmConso[i], vmCosts[i]))
    print("Profit: %d" % solver.Objective().Value())
</code></pre>


<h3>4.4 ...  <span class="badge badge-secondary">5 minutes</span></h3>
	Each server has a VM power consumption, for each VM placed on it, the server
   consumes Xw. (ex: if the VM power consumption on Server1 is equal to 100,
   then, if 2 VMs are placed on Server1, the Server1 power consumption is equal
   to 200. If the server is unused (no VM), it’s power consumption is equal to
   0). We want exactly nbRunning VM. We want to maximize our profit.
   Unfortunately, 1 W cost 1 dollar. So our profit is the sum of VM On minus the
   total power consumption. In this question, We want exactly nbRunning VM On
   and maximize our profit.
<pre><code class="language-python">from ortools.linear_solver import pywraplp

# Variables
serverCapacity = [ 10, 20, 10000 ]
serverCons = [ 100, 200, 10000 ]
nbServers = len(serverCapacity)
# We define the trash server as the last server of the list
trashServerIdx = nbServers - 1
vmConso = [ 5, 5, 3, 10, 7]
vmCosts = [ 10, 3, 5, 1, 9 ]
nbVms = len(vmConso)
nbRunning = 2

solver = pywraplp.Solver.CreateSolver('SCIP')

# Solver Variables
# y[j] = 1 if bin j is used.
servers = {}
for j in range(nbServers):
    servers[j] = solver.IntVar(0, 1, 'server_%i' % j)
# x[i, j] = 1 if item i is packed in bin j.
vms = {}
for i in range(nbVms):
    for j in range(nbServers):
        vms[(i, j)] = solver.IntVar(0, 1, 'vm_%i_%i' % (i, j))

# Constraints
# Each VM must be in exactly one server.
for i in range(nbVms):
    solver.Add(sum(vms[i, j] for j in range(nbServers)) == 1)
# The amount packed in each server cannot exceed its capacity.
for j in range(nbServers):
    solver.Add(sum(
        [ vms[i, j] * vmConso[i] for i in range(nbVms)]) <= servers[j] * serverCapacity[j])
# Off VM are hosted on the third server (trash server)
solver.Add(sum([ vms[i, trashServerIdx] for i in range(nbVms)]) == nbVms - nbRunning)
# Compute the cost of all VM hosted on a different server than the trash server
total_cost = []
for i in range(nbVms):
    for j in range(nbServers - 1):
        isRunning = sum([vms[i, j]])
        total_cost.append(isRunning * (vmCosts[i] - serverCons[j]))
solver.Maximize(sum(total_cost))

status = solver.Solve()
if status == pywraplp.Solver.INFEASIBLE:
    print("No Solution")
if status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:
    vmPlacement = []
    for j in range(nbServers):
        vmPlacement.append([])
    for i in range(nbVms):
        for j in range(nbServers):
            if vms[i, j].solution_value() == 1:
                vmPlacement[j].append(i)
    for idx, content in enumerate(vmPlacement):
        print("On server%d (capacity: %d):" % (idx, serverCapacity[idx]))
        for i in content:
            print("  vm%d (cons: %d, cost: %d, power: %d)" % (
                i, vmConso[i], vmCosts[i], serverCons[idx]))
    print("Profit: %d" % solver.Objective().Value())
</code></pre>





  </div> <!-- fin de <div class="border-top"> --> 
  <!-- FIN DE PARTIE 1 -->
 
  


<div class="alert alert-warning">
      <h4 class="alert alert-warning">Oufff.. finish!</h4>
</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-core.min.js" integrity="sha256-Y+Budm2wBEjYjbH0qcJRmLuRBFpXd0VKxl6XhdS4hgA=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-ht8ay6ZTPZfuixYB99I5oRpCLsCq7Do2LjEYLwbe+X8=" crossorigin="anonymous"></script>
</body>
</html>
